"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoStorage = void 0;
const tools_1 = require("@webcrypto/tools");
const idb_1 = require("idb");
/**
 * Crypto Storage service used to save and load local encrypted data using IndexedDB.
 */
class CryptoStorage {
    constructor(baseKeyOrConfig, dbName, storeName, salt, encryptIterations) {
        this.internalConfig = init((baseKeyOrConfig === null || baseKeyOrConfig === void 0 ? void 0 : baseKeyOrConfig.hasOwnProperty('baseKey')) ? baseKeyOrConfig
            : {
                baseKey: baseKeyOrConfig,
                dbName,
                storeName,
                salt,
                encryptIterations,
            });
    }
    /**
     * Loads and decrypt the stored data that match the given key.
     *
     * @param key The given key to find the data.
     * @returns Promise with the decrypted data that match the given key, or undefined if nothing was found.
     */
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const [[store, storeName, baseKey, salt, encryptIterations], hashKey, hashNonce] = yield all([
                this.internalConfig,
                tools_1.generateHash(key),
                tools_1.generateHash(key + '-nonce'),
            ]);
            const cryptoValue = yield store.get(storeName, hashKey);
            if (!cryptoValue)
                return;
            const [cryptoKey, nonce] = yield all([
                tools_1.deriveCryptKey(baseKey, salt, encryptIterations),
                store.get(storeName, hashNonce),
            ]);
            try {
                const value = yield tools_1.decryptValue(cryptoValue, cryptoKey, nonce);
                return tools_1.decode(value);
            }
            catch (error) {
                throw new Error(CryptoStorage.AuthenticityError);
            }
        });
    }
    /**
     * Encrypt and save the given data and key.
     *
     * @param key The key to be encrypted and find the data in the future.
     * @param value The value to be encrypted and stored.
     * @returns Promise to know when the encrypt and store process was complete.
     */
    set(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const [[store, storeName, baseKey, salt, encryptIterations], hashKey, hashNonce] = yield all([
                this.internalConfig,
                tools_1.generateHash(key),
                tools_1.generateHash(key + '-nonce'),
            ]);
            const cryptoKey = yield tools_1.deriveCryptKey(baseKey, salt, encryptIterations);
            const [cryptoValue, nonce] = yield tools_1.encryptValue(value, cryptoKey);
            yield all([store.put(storeName, cryptoValue, hashKey), store.put(storeName, nonce, hashNonce)]);
        });
    }
    /**
     * Erase all key and data stored at the current store and database, but keeping the structure.
     *
     * @returns Promise to know when the process was complete.
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            const [store, storeName, _, salt] = yield this.internalConfig;
            yield store.clear(storeName);
            yield verifySalt(store, storeName, salt);
        });
    }
    /**
     * Completely close the database connection.
     *
     * @returns Promise to know when the process was complete.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            const [store] = yield this.internalConfig;
            store.close();
        });
    }
    /**
     * Delete individual data that match the given key.
     *
     * @param key The given key to find the data.
     * @returns Promise to know when the process was complete.
     */
    delete(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const [[store, storeName], hashKey, hashNonce] = yield all([
                this.internalConfig,
                tools_1.generateHash(key),
                tools_1.generateHash(key + '-nonce'),
            ]);
            yield all([store.delete(storeName, hashKey), store.delete(storeName, hashNonce)]);
        });
    }
    /**
     * Fully delete not only all the key and data stored at the current store and database,
     * but also deleting the whole store and database the structure.
     *
     * @returns Promise to know when the process was complete.
     */
    deleteDB() {
        return __awaiter(this, void 0, void 0, function* () {
            const [store] = yield this.internalConfig;
            store.close();
            yield idb_1.deleteDB(store.name);
        });
    }
}
exports.CryptoStorage = CryptoStorage;
/**
 * Default authenticity error message when the `CryptoStorage` were not able de decrypt the stored data.
 */
CryptoStorage.AuthenticityError = 'Integrity/Authenticity check failed!';
/**
 * Default error message when a crypto key were not given.
 */
CryptoStorage.CryptoKeyError = 'CryptoStorage needs a base key to work properly';
/**
 * @internal
 */
const all = Promise.all.bind(Promise);
/**
 * @internal
 */
const init = ({ baseKey, dbName = 'default-key-value-db', storeName = 'default-key-value-storage', salt, encryptIterations, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!baseKey)
        throw new Error(CryptoStorage.CryptoKeyError);
    const [dbHashName, storeHashName, cryptoBaseKey] = yield all([
        tools_1.generateHash(dbName),
        tools_1.generateHash(storeName),
        baseKey instanceof CryptoKey ? baseKey : tools_1.generateBaseCryptoKey(baseKey),
    ]);
    const decodedStorageName = tools_1.decode(storeHashName);
    const store = idb_1.openDB(tools_1.decode(dbHashName), 1, {
        upgrade(db) {
            db.createObjectStore(decodedStorageName);
        },
    });
    return all([
        store,
        decodedStorageName,
        cryptoBaseKey,
        verifySalt(store, decodedStorageName, salt),
        encryptIterations,
    ]);
});
/**
 * @internal
 */
const verifySalt = (storePromise, storeName, salt) => __awaiter(void 0, void 0, void 0, function* () {
    const [hash, store] = yield all([tools_1.generateHash('salt'), storePromise]);
    const existingSalt = yield store.get(storeName, hash);
    if (existingSalt && (!salt || existingSalt === salt)) {
        return existingSalt;
    }
    return persistSalt(hash, store, storeName, salt);
});
/**
 * @internal
 */
const persistSalt = (saltHash, store, storeName, currentSalt) => __awaiter(void 0, void 0, void 0, function* () {
    const salt = currentSalt !== null && currentSalt !== void 0 ? currentSalt : tools_1.generateSalt();
    yield store.put(storeName, salt, saltHash);
    return salt;
});
//# sourceMappingURL=web-crypto-storage.js.map