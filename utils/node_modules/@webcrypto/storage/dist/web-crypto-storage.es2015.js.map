{"version":3,"file":"web-crypto-storage.es2015.js","sources":["../node_modules/@webcrypto/tools/src/web-crypto-tools.ts","../node_modules/idb/build/esm/wrap-idb-value.js","../node_modules/idb/build/esm/index.js","../src/web-crypto-storage.ts"],"sourcesContent":["/**\n * Import Key Algorithms at Web Crypto API\n */\nexport type ImportAlgorithm =\n  | string\n  | RsaHashedImportParams\n  | EcKeyImportParams\n  | HmacImportParams\n  | DhImportKeyParams\n  | AesKeyAlgorithm;\n\n/**\n * Import Key Web Crypto Algorithms\n */\nexport type OriginalKeyFormat = 'raw' | 'pkcs8' | 'spki' | 'jwk';\n\n/**\n * Derive Key Algorithms at at Web Crypto API\n */\nexport type DeriveAlgorithm =\n  | string\n  | EcdhKeyDeriveParams\n  | DhKeyDeriveParams\n  | ConcatParams\n  | HkdfCtrParams\n  | Pbkdf2Params;\n\n/**\n * Derive Algorithms Params for Web Crypto API\n */\nexport type DerivedAlgorithmFor =\n  | string\n  | AesDerivedKeyParams\n  | HmacImportParams\n  | ConcatParams\n  | HkdfCtrParams\n  | Pbkdf2Params;\n\n/**\n * Params for Encrypt / Decrypt Algorithms at Web Crypto API\n */\nexport type CryptoAlgorithm =\n  | string\n  | RsaOaepParams\n  | AesCtrParams\n  | AesCbcParams\n  | AesCmacParams\n  | AesGcmParams\n  | AesCfbParams;\n\n/**\n * TypedArray used in Web Crypto API Algorithms\n */\nexport type TypedArray =\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array\n  | DataView\n  | ArrayBuffer;\n\n/**\n * Possible uses of Crypto Keys\n */\nexport type CryptoKeyUsage =\n  | 'encrypt'\n  | 'decrypt'\n  | 'deriveKey'\n  | 'deriveBits'\n  | 'wrapKey'\n  | 'sign'\n  | 'verify'\n  | 'unwrapKey';\n\n/**\n * Default number of iterations used with PBKDF2 algorithm\n */\nexport const PBKDF2_ITERATIONS_DEFAULT: number = 50000;\n\n/**\n * @internal\n */\ndeclare global {\n  /**\n   * IE11 use a different global property.\n   * @internal\n   */\n  var msCrypto: Crypto;\n}\n\n/**\n * Returns the crypto object depending on browser support.\n * IE11 has support for the Crypto API, but it is in a different global scope.\n *\n * @returns The Crypto object.\n */\nexport function getCryptoObject(): Crypto {\n  return window.crypto || window.msCrypto; // for IE 11\n}\n\n/**\n * Creates a base Crypto Key from the original raw key, by default this base key\n * should just be used to protect the original key to be discovery,\n * and should not be used directly to any encrypt / decrypt algorithm.\n * The generated base crypto key should be used just to derive new ones,\n * that then will be used to encrypt / decrypt algorithms.\n *\n * @param rawKey The original key to start the encrypt process.\n * @param algorithm The algorithm used to import the key.\n * @param keyUsages The uses for the generated Crypto Key.\n * @param format Input format for the raw key.\n * @returns A promise with the base Crypto Key.\n */\nexport function generateBaseCryptoKey(\n  rawKey: string | TypedArray | JsonWebKey,\n  algorithm: ImportAlgorithm = 'PBKDF2',\n  keyUsages: KeyUsage[] = ['deriveKey'],\n  format: OriginalKeyFormat = 'raw',\n): Promise<CryptoKey> {\n  const isJwkKey = !isTypedArray(rawKey) && typeof rawKey === 'object';\n  return Promise.resolve(\n    getCryptoObject().subtle.importKey(\n      isJwkKey ? 'jwk' : format,\n      typeof rawKey === 'string' ? encode(rawKey) : rawKey,\n      algorithm,\n      false, // the original value will not be extractable\n      keyUsages,\n    ),\n  );\n}\n\n/**\n * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms\n * or any other possible uses in `CryptoKeyUsage`.\n *\n * @param cryptoBaseKey The base Crypto Key to be derive.\n * @param salt The salt value to be used with the default `PBKDF2` derive algorithm.\n * @param iterations The number of iterations to be used with the default `PBKDF2` derive algorithm. Default value: `PBKDF2_ITERATIONS_DEFAULT`.\n * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.\n * @returns A promise with the derived Crypto Key for other uses.\n */\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  salt: TypedArray,\n  iterations?: number,\n  keyUsages?: CryptoKeyUsage[],\n): Promise<CryptoKey>;\n\n/**\n * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms\n * or any other possible uses in `CryptoKeyUsage`.\n *\n * @param cryptoBaseKey The base Crypto Key to be derive.\n * @param salt The salt value to be used with the default `PBKDF2` derive algorithm.\n * @param algorithmFor The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`.\n * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.\n * @returns A promise with the derived Crypto Key for other uses.\n */\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  salt: TypedArray,\n  algorithmFor?: DerivedAlgorithmFor,\n  keyUsages?: CryptoKeyUsage[],\n): Promise<CryptoKey>;\n\n/**\n * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms\n * or any other possible uses in `CryptoKeyUsage`.\n *\n * @param cryptoBaseKey The base Crypto Key to be derive.\n * @param deriveAlgorithm The algorithm to be used when deriving the Crypto Key.\n * @param algorithmFor The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`.\n * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.\n * @returns A promise with the derived Crypto Key for other uses.\n */\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  deriveAlgorithm: DeriveAlgorithm,\n  algorithmFor?: DerivedAlgorithmFor,\n  keyUsages?: CryptoKeyUsage[],\n): Promise<CryptoKey>;\n\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  deriveAlgorithmOrSalt: DeriveAlgorithm | TypedArray,\n  algorithmForOrIterations: DerivedAlgorithmFor | number = PBKDF2_ITERATIONS_DEFAULT,\n  keyUsages: CryptoKeyUsage[] = ['encrypt', 'decrypt'],\n): Promise<CryptoKey> {\n  const deriveAlgorithm = isTypedArray(deriveAlgorithmOrSalt)\n    ? ({\n        name: 'PBKDF2',\n        hash: 'SHA-256',\n        salt: deriveAlgorithmOrSalt,\n        iterations:\n          typeof algorithmForOrIterations === 'number'\n            ? algorithmForOrIterations\n            : PBKDF2_ITERATIONS_DEFAULT,\n      } as Pbkdf2Params)\n    : deriveAlgorithmOrSalt;\n\n  // The derived key will be used to encrypt with AES by default.\n  const algorithmFor =\n    typeof algorithmForOrIterations === 'number'\n      ? ({ name: 'AES-GCM', length: 256 } as AesDerivedKeyParams)\n      : algorithmForOrIterations;\n\n  return Promise.resolve(\n    getCryptoObject().subtle.deriveKey(\n      deriveAlgorithm,\n      cryptoBaseKey,\n      algorithmFor,\n      false, // the original key will not be extractable\n      keyUsages,\n    ),\n  );\n}\n\n/**\n * Type Guard to Typed Array.\n *\n * @param data Any data to be checked.\n * @returns Verify if the given data is a Typed Array.\n */\nexport function isTypedArray(data: unknown): data is TypedArray {\n  return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;\n}\n\n/**\n * Encrypt a value with the given Crypto Key and Algorithm\n *\n * @param data Value to be encrypted.\n * @param cryptoKey The Crypto Key to be used in encryption.\n * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.\n * @returns A promise with the encrypted value and the used nonce, if used with the encryption algorithm.\n */\nexport function encryptValue(\n  data: string | TypedArray,\n  cryptoKey: CryptoKey,\n  algorithm: CryptoAlgorithm = { name: 'AES-GCM', iv: generateNonce() } as AesGcmParams,\n): Promise<[ArrayBuffer, TypedArray | null]> {\n  return Promise.resolve(\n    getCryptoObject().subtle.encrypt(algorithm, cryptoKey, encode(data)),\n  ).then(cryptoValue => [cryptoValue, (algorithm as AesGcmParams).iv || null]);\n}\n\n/**\n * Decrypt a value with the given Crypto Key and Algorithm\n *\n * @param data Value to be encrypted.\n * @param cryptoKey The Crypto Key used in encryption.\n * @param nonceOrAlgorithm The nonce used for AES encryption or the custom algorithm.\n * @returns A promise with the decrypt value\n */\nexport function decryptValue(\n  data: TypedArray,\n  cryptoKey: CryptoKey,\n  nonceOrAlgorithm: TypedArray | CryptoAlgorithm,\n): Promise<ArrayBuffer> {\n  const algorithm = isTypedArray(nonceOrAlgorithm)\n    ? ({ name: 'AES-GCM', iv: nonceOrAlgorithm } as AesGcmParams)\n    : nonceOrAlgorithm;\n  return Promise.resolve(getCryptoObject().subtle.decrypt(algorithm, cryptoKey, data));\n}\n\n/**\n * Generates random value to be used as nonce with encryption algorithms.\n *\n * @param byteSize The byte size of the generated random value.\n * @returns The random value.\n */\nexport function generateNonce(byteSize = 16): Uint8Array {\n  // We should generate at least 16 bytes\n  // to allow for 2^128 possible variations.\n  return generateRandomValues(byteSize);\n}\n\n/**\n * Generates random value to be used as salt with encryption algorithms.\n *\n * @param byteSize The byte size of the generated random value.\n * @returns The random value.\n */\nexport function generateSalt(byteSize = 8): Uint8Array {\n  // We should generate at least 8 bytes\n  // to allow for 2^64 possible variations.\n  return generateRandomValues(byteSize);\n}\n\n/**\n * Generates random value as a typed array of `Uint8Array`.\n *\n * @param byteSize The byte size of the generated random value.\n * @returns The random value.\n */\nexport function generateRandomValues(byteSize = 8): Uint8Array {\n  return getCryptoObject().getRandomValues(new Uint8Array(byteSize));\n}\n\n/**\n * Encode a string value to a Typed Array as `Uint8Array`.\n * If the given value is already a Typed Array, then the value will be returned without any transformation.\n *\n * @param data Value to be encoded.\n * @returns The transformed given value as a Typed Array.\n */\nexport function encode(data: string | TypedArray): TypedArray {\n  return isTypedArray(data) ? data : new TextEncoder().encode(data);\n}\n\n/**\n * Decode a ArrayBuffer value to a string.\n * If the given value is already a string, then the value will be returned without any transformation.\n *\n * @param data Value to be decoded.\n * @returns The transformed given value as a string.\n */\nexport function decode(data: string | TypedArray): string {\n  return typeof data === 'string' ? data : new TextDecoder('utf-8').decode(data);\n}\n\n/**\n * Generates a hash value for the given value.\n *\n * @param data Seed value to generate a hash.\n * @param algorithm The algorithm to be used when generating the hash.\n * @returns A promise containing the hash value.\n */\nexport function generateHash(\n  data: string | TypedArray,\n  algorithm: string | Algorithm = 'SHA-256',\n): Promise<ArrayBuffer> {\n  return Promise.resolve(getCryptoObject().subtle.digest(algorithm, encode(data)));\n}\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = await target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import {\n  decode,\n  decryptValue,\n  deriveCryptKey,\n  encryptValue,\n  generateBaseCryptoKey,\n  generateHash,\n  generateSalt,\n  TypedArray,\n} from '@webcrypto/tools';\nimport { deleteDB, IDBPDatabase, openDB } from 'idb';\n\n/**\n * Default input data formats to be encrypted and stored.\n */\nexport type InputData = string | TypedArray;\n\n/**\n * Configuration used to initialize the Crypto Storage.\n */\nexport interface CryptoStorageConfig {\n  /**\n   * Base key used to encrypt the stored data.\n   */\n  baseKey: InputData | CryptoKey;\n  /**\n   * Database name used to store the data.\n   */\n  dbName?: string;\n  /**\n   * Storage name used to store the data.\n   */\n  storeName?: string;\n  /**\n   * Custom salt used to encrypt the stored data.\n   */\n  salt?: TypedArray;\n  /**\n   * Custom iteration cycles to encrypt the stored data.\n   */\n  encryptIterations?: number;\n}\n\n/**\n * @internal\n */\ntype InternalConfig = [IDBPDatabase<any>, string, CryptoKey, TypedArray, number | undefined];\n\n/**\n * Crypto Storage service used to save and load local encrypted data using IndexedDB.\n */\nexport class CryptoStorage {\n  /**\n   * Default authenticity error message when the `CryptoStorage` were not able de decrypt the stored data.\n   */\n  static AuthenticityError = 'Integrity/Authenticity check failed!';\n\n  /**\n   * Default error message when a crypto key were not given.\n   */\n  static CryptoKeyError = 'CryptoStorage needs a base key to work properly';\n\n  /**\n   * @internal\n   */\n  private internalConfig: Promise<InternalConfig>;\n\n  /**\n   * Base constructor that receive all the configuration as an object.\n   */\n  constructor(config: CryptoStorageConfig);\n  /**\n   * Base constructor.\n   * @param baseKey Base key used to encrypt the stored data.\n   * @param dbName Database name used to store the data.\n   * @param storeName Storage name used to store the data.\n   * @param salt Custom salt used to encrypt the stored data.\n   * @param encryptIterations Custom iteration cycles to encrypt the stored data.\n   */\n  constructor(\n    baseKey: InputData | CryptoKey,\n    dbName?: string,\n    storeName?: string,\n    salt?: TypedArray,\n    encryptIterations?: number,\n  );\n  constructor(\n    baseKeyOrConfig: InputData | CryptoKey | CryptoStorageConfig,\n    dbName?: string,\n    storeName?: string,\n    salt?: TypedArray,\n    encryptIterations?: number,\n  ) {\n    this.internalConfig = init(\n      baseKeyOrConfig?.hasOwnProperty('baseKey')\n        ? (baseKeyOrConfig as CryptoStorageConfig)\n        : ({\n            baseKey: baseKeyOrConfig,\n            dbName,\n            storeName,\n            salt,\n            encryptIterations,\n          } as CryptoStorageConfig),\n    );\n  }\n\n  /**\n   * Loads and decrypt the stored data that match the given key.\n   *\n   * @param key The given key to find the data.\n   * @returns Promise with the decrypted data that match the given key, or undefined if nothing was found.\n   */\n  async get(key: InputData): Promise<string | undefined> {\n    const [[store, storeName, baseKey, salt, encryptIterations], hashKey, hashNonce] = await all([\n      this.internalConfig,\n      generateHash(key),\n      generateHash(key + '-nonce'),\n    ]);\n\n    const cryptoValue = await store.get(storeName, hashKey);\n    if (!cryptoValue) return;\n\n    const [cryptoKey, nonce] = await all([\n      deriveCryptKey(baseKey, salt, encryptIterations),\n      store.get(storeName, hashNonce),\n    ]);\n\n    try {\n      const value = await decryptValue(cryptoValue, cryptoKey, nonce);\n      return decode(value);\n    } catch (error) {\n      throw new Error(CryptoStorage.AuthenticityError);\n    }\n  }\n\n  /**\n   * Encrypt and save the given data and key.\n   *\n   * @param key The key to be encrypted and find the data in the future.\n   * @param value The value to be encrypted and stored.\n   * @returns Promise to know when the encrypt and store process was complete.\n   */\n  async set(key: InputData, value: InputData): Promise<void> {\n    const [[store, storeName, baseKey, salt, encryptIterations], hashKey, hashNonce] = await all([\n      this.internalConfig,\n      generateHash(key),\n      generateHash(key + '-nonce'),\n    ]);\n\n    const cryptoKey = await deriveCryptKey(baseKey, salt, encryptIterations);\n    const [cryptoValue, nonce] = await encryptValue(value, cryptoKey);\n    await all([store.put(storeName, cryptoValue, hashKey), store.put(storeName, nonce, hashNonce)]);\n  }\n\n  /**\n   * Erase all key and data stored at the current store and database, but keeping the structure.\n   *\n   * @returns Promise to know when the process was complete.\n   */\n  async clear(): Promise<void> {\n    const [store, storeName, _, salt] = await this.internalConfig;\n    await store.clear(storeName);\n    await verifySalt(store, storeName, salt);\n  }\n\n  /**\n   * Completely close the database connection.\n   *\n   * @returns Promise to know when the process was complete.\n   */\n  async close(): Promise<void> {\n    const [store] = await this.internalConfig;\n    store.close();\n  }\n\n  /**\n   * Delete individual data that match the given key.\n   *\n   * @param key The given key to find the data.\n   * @returns Promise to know when the process was complete.\n   */\n  async delete(key: InputData): Promise<void> {\n    const [[store, storeName], hashKey, hashNonce] = await all([\n      this.internalConfig,\n      generateHash(key),\n      generateHash(key + '-nonce'),\n    ]);\n    await all([store.delete(storeName, hashKey), store.delete(storeName, hashNonce)]);\n  }\n\n  /**\n   * Fully delete not only all the key and data stored at the current store and database,\n   * but also deleting the whole store and database the structure.\n   *\n   * @returns Promise to know when the process was complete.\n   */\n  async deleteDB(): Promise<void> {\n    const [store] = await this.internalConfig;\n    store.close();\n    await deleteDB(store.name);\n  }\n}\n\n/**\n * @internal\n */\nconst all = Promise.all.bind(Promise);\n\n/**\n * @internal\n */\nconst init = async ({\n  baseKey,\n  dbName = 'default-key-value-db',\n  storeName = 'default-key-value-storage',\n  salt,\n  encryptIterations,\n}: CryptoStorageConfig): Promise<InternalConfig> => {\n  if (!baseKey) throw new Error(CryptoStorage.CryptoKeyError);\n  const [dbHashName, storeHashName, cryptoBaseKey] = await all([\n    generateHash(dbName),\n    generateHash(storeName),\n    baseKey instanceof CryptoKey ? baseKey : generateBaseCryptoKey(baseKey),\n  ]);\n  const decodedStorageName = decode(storeHashName);\n  const store = openDB(decode(dbHashName), 1, {\n    upgrade(db) {\n      db.createObjectStore(decodedStorageName);\n    },\n  });\n  return all([\n    store,\n    decodedStorageName,\n    cryptoBaseKey,\n    verifySalt(store, decodedStorageName, salt),\n    encryptIterations,\n  ]);\n};\n\n/**\n * @internal\n */\nconst verifySalt = async (\n  storePromise: IDBPDatabase | Promise<IDBPDatabase>,\n  storeName: string,\n  salt?: TypedArray,\n): Promise<TypedArray> => {\n  const [hash, store] = await all([generateHash('salt'), storePromise]);\n  const existingSalt = await store.get(storeName, hash);\n  if (existingSalt && (!salt || existingSalt === salt)) {\n    return existingSalt;\n  }\n  return persistSalt(hash, store, storeName, salt);\n};\n\n/**\n * @internal\n */\nconst persistSalt = async (\n  saltHash: TypedArray,\n  store: IDBPDatabase,\n  storeName: string,\n  currentSalt?: TypedArray,\n): Promise<TypedArray> => {\n  const salt = currentSalt ?? generateSalt();\n  await store.put(storeName, salt, saltHash);\n  return salt;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AA+EA;;;AAGA,IAAa,yBAAyB,GAAW,KAAK,CAAC;;;;;;;AAmBvD,SAAgB,eAAe;IAC7B,OAAO,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,QAAQ,CAAC;CACzC;;;;;;;;;;;;;;AAeD,SAAgB,qBAAqB,CACnC,MAAwC,EACxC,SAAqC,EACrC,SAAqC,EACrC,MAAiC;IAFjC,0BAAA,EAAA,oBAAqC;IACrC,0BAAA,EAAA,aAAyB,WAAW,CAAC;IACrC,uBAAA,EAAA,cAAiC;IAEjC,IAAM,QAAQ,GAAG,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,OAAO,MAAM,KAAK,QAAQ,CAAC;IACrE,OAAO,OAAO,CAAC,OAAO,CACpB,eAAe,EAAE,CAAC,MAAM,CAAC,SAAS,CAChC,QAAQ,GAAG,KAAK,GAAG,MAAM,EACzB,OAAO,MAAM,KAAK,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,MAAM,EACpD,SAAS,EACT,KAAK;IACL,SAAS,CACV,CACF,CAAC;CACH;AAqDD,SAAgB,cAAc,CAC5B,aAAwB,EACxB,qBAAmD,EACnD,wBAAkF,EAClF,SAAoD;IADpD,yCAAA,EAAA,oDAAkF;IAClF,0BAAA,EAAA,aAA+B,SAAS,EAAE,SAAS,CAAC;IAEpD,IAAM,eAAe,GAAG,YAAY,CAAC,qBAAqB,CAAC;UACtD;YACC,IAAI,EAAE,QAAQ;YACd,IAAI,EAAE,SAAS;YACf,IAAI,EAAE,qBAAqB;YAC3B,UAAU,EACR,OAAO,wBAAwB,KAAK,QAAQ;kBACxC,wBAAwB;kBACxB,yBAAyB;SACf;UAClB,qBAAqB,CAAC;;IAG1B,IAAM,YAAY,GAChB,OAAO,wBAAwB,KAAK,QAAQ;UACvC,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,EAAE,GAAG,EAA0B;UACzD,wBAAwB,CAAC;IAE/B,OAAO,OAAO,CAAC,OAAO,CACpB,eAAe,EAAE,CAAC,MAAM,CAAC,SAAS,CAChC,eAAe,EACf,aAAa,EACb,YAAY,EACZ,KAAK;IACL,SAAS,CACV,CACF,CAAC;CACH;;;;;;;AAQD,SAAgB,YAAY,CAAC,IAAa;IACxC,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,IAAI,YAAY,WAAW,CAAC;CAChE;;;;;;;;;AAUD,SAAgB,YAAY,CAC1B,IAAyB,EACzB,SAAoB,EACpB,SAAqF;IAArF,0BAAA,EAAA,YAA6B,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE,aAAa,EAAE,EAAkB;IAErF,OAAO,OAAO,CAAC,OAAO,CACpB,eAAe,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CACrE,CAAC,IAAI,CAAC,UAAA,WAAW,IAAI,OAAA,CAAC,WAAW,EAAG,SAA0B,CAAC,EAAE,IAAI,IAAI,CAAC,GAAA,CAAC,CAAC;CAC9E;;;;;;;;;AAUD,SAAgB,YAAY,CAC1B,IAAgB,EAChB,SAAoB,EACpB,gBAA8C;IAE9C,IAAM,SAAS,GAAG,YAAY,CAAC,gBAAgB,CAAC;UAC3C,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,EAAE,gBAAgB,EAAmB;UAC3D,gBAAgB,CAAC;IACrB,OAAO,OAAO,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC,CAAC;CACtF;;;;;;;AAQD,SAAgB,aAAa,CAAC,QAAa;IAAb,yBAAA,EAAA,aAAa;;;IAGzC,OAAO,oBAAoB,CAAC,QAAQ,CAAC,CAAC;CACvC;;;;;;;AAQD,SAAgB,YAAY,CAAC,QAAY;IAAZ,yBAAA,EAAA,YAAY;;;IAGvC,OAAO,oBAAoB,CAAC,QAAQ,CAAC,CAAC;CACvC;;;;;;;AAQD,SAAgB,oBAAoB,CAAC,QAAY;IAAZ,yBAAA,EAAA,YAAY;IAC/C,OAAO,eAAe,EAAE,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;CACpE;;;;;;;;AASD,SAAgB,MAAM,CAAC,IAAyB;IAC9C,OAAO,YAAY,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;CACnE;;;;;;;;AASD,SAAgB,MAAM,CAAC,IAAyB;IAC9C,OAAO,OAAO,IAAI,KAAK,QAAQ,GAAG,IAAI,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;CAChF;;;;;;;;AASD,SAAgB,YAAY,CAC1B,IAAyB,EACzB,SAAyC;IAAzC,0BAAA,EAAA,qBAAyC;IAEzC,OAAO,OAAO,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;;AChVnF,MAAM,aAAa,GAAG,CAAC,MAAM,EAAE,YAAY,KAAK,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,YAAY,CAAC,CAAC,CAAC;AAC9F;AACA,IAAI,iBAAiB,CAAC;AACtB,IAAI,oBAAoB,CAAC;AACzB;AACA,SAAS,oBAAoB,GAAG;AAChC,IAAI,QAAQ,iBAAiB;AAC7B,SAAS,iBAAiB,GAAG;AAC7B,YAAY,WAAW;AACvB,YAAY,cAAc;AAC1B,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,cAAc;AAC1B,SAAS,CAAC,EAAE;AACZ,CAAC;AACD;AACA,SAAS,uBAAuB,GAAG;AACnC,IAAI,QAAQ,oBAAoB;AAChC,SAAS,oBAAoB,GAAG;AAChC,YAAY,SAAS,CAAC,SAAS,CAAC,OAAO;AACvC,YAAY,SAAS,CAAC,SAAS,CAAC,QAAQ;AACxC,YAAY,SAAS,CAAC,SAAS,CAAC,kBAAkB;AAClD,SAAS,CAAC,EAAE;AACZ,CAAC;AACD,MAAM,gBAAgB,GAAG,IAAI,OAAO,EAAE,CAAC;AACvC,MAAM,kBAAkB,GAAG,IAAI,OAAO,EAAE,CAAC;AACzC,MAAM,wBAAwB,GAAG,IAAI,OAAO,EAAE,CAAC;AAC/C,MAAM,cAAc,GAAG,IAAI,OAAO,EAAE,CAAC;AACrC,MAAM,qBAAqB,GAAG,IAAI,OAAO,EAAE,CAAC;AAC5C,SAAS,gBAAgB,CAAC,OAAO,EAAE;AACnC,IAAI,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AACrD,QAAQ,MAAM,QAAQ,GAAG,MAAM;AAC/B,YAAY,OAAO,CAAC,mBAAmB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AAC5D,YAAY,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACxD,SAAS,CAAC;AACV,QAAQ,MAAM,OAAO,GAAG,MAAM;AAC9B,YAAY,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AAC1C,YAAY,QAAQ,EAAE,CAAC;AACvB,SAAS,CAAC;AACV,QAAQ,MAAM,KAAK,GAAG,MAAM;AAC5B,YAAY,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAClC,YAAY,QAAQ,EAAE,CAAC;AACvB,SAAS,CAAC;AACV,QAAQ,OAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;AACrD,QAAQ,OAAO,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACjD,KAAK,CAAC,CAAC;AACP,IAAI,OAAO;AACX,SAAS,IAAI,CAAC,CAAC,KAAK,KAAK;AACzB;AACA;AACA,QAAQ,IAAI,KAAK,YAAY,SAAS,EAAE;AACxC,YAAY,gBAAgB,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AACjD,SAAS;AACT;AACA,KAAK,CAAC;AACN,SAAS,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAC1B;AACA;AACA,IAAI,qBAAqB,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AAChD,IAAI,OAAO,OAAO,CAAC;AACnB,CAAC;AACD,SAAS,8BAA8B,CAAC,EAAE,EAAE;AAC5C;AACA,IAAI,IAAI,kBAAkB,CAAC,GAAG,CAAC,EAAE,CAAC;AAClC,QAAQ,OAAO;AACf,IAAI,MAAM,IAAI,GAAG,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,KAAK;AAClD,QAAQ,MAAM,QAAQ,GAAG,MAAM;AAC/B,YAAY,EAAE,CAAC,mBAAmB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AACzD,YAAY,EAAE,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACnD,YAAY,EAAE,CAAC,mBAAmB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACnD,SAAS,CAAC;AACV,QAAQ,MAAM,QAAQ,GAAG,MAAM;AAC/B,YAAY,OAAO,EAAE,CAAC;AACtB,YAAY,QAAQ,EAAE,CAAC;AACvB,SAAS,CAAC;AACV,QAAQ,MAAM,KAAK,GAAG,MAAM;AAC5B,YAAY,MAAM,CAAC,EAAE,CAAC,KAAK,IAAI,IAAI,YAAY,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC,CAAC;AAC7E,YAAY,QAAQ,EAAE,CAAC;AACvB,SAAS,CAAC;AACV,QAAQ,EAAE,CAAC,gBAAgB,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;AAClD,QAAQ,EAAE,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAC5C,QAAQ,EAAE,CAAC,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAC5C,KAAK,CAAC,CAAC;AACP;AACA,IAAI,kBAAkB,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AACrC,CAAC;AACD,IAAI,aAAa,GAAG;AACpB,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE;AAChC,QAAQ,IAAI,MAAM,YAAY,cAAc,EAAE;AAC9C;AACA,YAAY,IAAI,IAAI,KAAK,MAAM;AAC/B,gBAAgB,OAAO,kBAAkB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACtD;AACA,YAAY,IAAI,IAAI,KAAK,kBAAkB,EAAE;AAC7C,gBAAgB,OAAO,MAAM,CAAC,gBAAgB,IAAI,wBAAwB,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACvF,aAAa;AACb;AACA,YAAY,IAAI,IAAI,KAAK,OAAO,EAAE;AAClC,gBAAgB,OAAO,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC;AACnD,sBAAsB,SAAS;AAC/B,sBAAsB,QAAQ,CAAC,WAAW,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;AACzE,aAAa;AACb,SAAS;AACT;AACA,QAAQ,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE;AAC7B,QAAQ,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;AAC7B,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE;AACtB,QAAQ,IAAI,MAAM,YAAY,cAAc;AAC5C,aAAa,IAAI,KAAK,MAAM,IAAI,IAAI,KAAK,OAAO,CAAC,EAAE;AACnD,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,OAAO,IAAI,IAAI,MAAM,CAAC;AAC9B,KAAK;AACL,CAAC,CAAC;AACF,SAAS,YAAY,CAAC,QAAQ,EAAE;AAChC,IAAI,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC,CAAC;AAC5C,CAAC;AACD,SAAS,YAAY,CAAC,IAAI,EAAE;AAC5B;AACA;AACA;AACA,IAAI,IAAI,IAAI,KAAK,WAAW,CAAC,SAAS,CAAC,WAAW;AAClD,QAAQ,EAAE,kBAAkB,IAAI,cAAc,CAAC,SAAS,CAAC,EAAE;AAC3D,QAAQ,OAAO,UAAU,UAAU,EAAE,GAAG,IAAI,EAAE;AAC9C,YAAY,MAAM,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,CAAC;AACpE,YAAY,wBAAwB,CAAC,GAAG,CAAC,EAAE,EAAE,UAAU,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;AACjG,YAAY,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC;AAC5B,SAAS,CAAC;AACV,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,IAAI,uBAAuB,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AAClD,QAAQ,OAAO,UAAU,GAAG,IAAI,EAAE;AAClC;AACA;AACA,YAAY,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC;AAC3C,YAAY,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;AACpD,SAAS,CAAC;AACV,KAAK;AACL,IAAI,OAAO,UAAU,GAAG,IAAI,EAAE;AAC9B;AACA;AACA,QAAQ,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACpD,KAAK,CAAC;AACN,CAAC;AACD,SAAS,sBAAsB,CAAC,KAAK,EAAE;AACvC,IAAI,IAAI,OAAO,KAAK,KAAK,UAAU;AACnC,QAAQ,OAAO,YAAY,CAAC,KAAK,CAAC,CAAC;AACnC;AACA;AACA,IAAI,IAAI,KAAK,YAAY,cAAc;AACvC,QAAQ,8BAA8B,CAAC,KAAK,CAAC,CAAC;AAC9C,IAAI,IAAI,aAAa,CAAC,KAAK,EAAE,oBAAoB,EAAE,CAAC;AACpD,QAAQ,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE,aAAa,CAAC,CAAC;AAC/C;AACA,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD,SAAS,IAAI,CAAC,KAAK,EAAE;AACrB;AACA;AACA,IAAI,IAAI,KAAK,YAAY,UAAU;AACnC,QAAQ,OAAO,gBAAgB,CAAC,KAAK,CAAC,CAAC;AACvC;AACA;AACA,IAAI,IAAI,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC;AACjC,QAAQ,OAAO,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;AACzC,IAAI,MAAM,QAAQ,GAAG,sBAAsB,CAAC,KAAK,CAAC,CAAC;AACnD;AACA;AACA,IAAI,IAAI,QAAQ,KAAK,KAAK,EAAE;AAC5B,QAAQ,cAAc,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;AAC5C,QAAQ,qBAAqB,CAAC,GAAG,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;AACnD,KAAK;AACL,IAAI,OAAO,QAAQ,CAAC;AACpB,CAAC;AACD,MAAM,MAAM,GAAG,CAAC,KAAK,KAAK,qBAAqB,CAAC,GAAG,CAAC,KAAK,CAAC;;ACnL1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,GAAG,EAAE,EAAE;AAChF,IAAI,MAAM,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AAClD,IAAI,MAAM,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC;AACtC,IAAI,IAAI,OAAO,EAAE;AACjB,QAAQ,OAAO,CAAC,gBAAgB,CAAC,eAAe,EAAE,CAAC,KAAK,KAAK;AAC7D,YAAY,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,UAAU,EAAE,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC;AACzG,SAAS,CAAC,CAAC;AACX,KAAK;AACL,IAAI,IAAI,OAAO;AACf,QAAQ,OAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,MAAM,OAAO,EAAE,CAAC,CAAC;AAC7D,IAAI,WAAW;AACf,SAAS,IAAI,CAAC,CAAC,EAAE,KAAK;AACtB,QAAQ,IAAI,UAAU;AACtB,YAAY,EAAE,CAAC,gBAAgB,CAAC,OAAO,EAAE,MAAM,UAAU,EAAE,CAAC,CAAC;AAC7D,QAAQ,IAAI,QAAQ;AACpB,YAAY,EAAE,CAAC,gBAAgB,CAAC,eAAe,EAAE,MAAM,QAAQ,EAAE,CAAC,CAAC;AACnE,KAAK,CAAC;AACN,SAAS,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;AAC1B,IAAI,OAAO,WAAW,CAAC;AACvB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ,CAAC,IAAI,EAAE,EAAE,OAAO,EAAE,GAAG,EAAE,EAAE;AAC1C,IAAI,MAAM,OAAO,GAAG,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;AACnD,IAAI,IAAI,OAAO;AACf,QAAQ,OAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,MAAM,OAAO,EAAE,CAAC,CAAC;AAC7D,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,MAAM,SAAS,CAAC,CAAC;AAC/C,CAAC;AACD;AACA,MAAM,WAAW,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC;AACvE,MAAM,YAAY,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AACvD,MAAM,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;AAChC,SAAS,SAAS,CAAC,MAAM,EAAE,IAAI,EAAE;AACjC,IAAI,IAAI,EAAE,MAAM,YAAY,WAAW;AACvC,QAAQ,EAAE,IAAI,IAAI,MAAM,CAAC;AACzB,QAAQ,OAAO,IAAI,KAAK,QAAQ,CAAC,EAAE;AACnC,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC;AAC/B,QAAQ,OAAO,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;AACvC,IAAI,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AAC1D,IAAI,MAAM,QAAQ,GAAG,IAAI,KAAK,cAAc,CAAC;AAC7C,IAAI,MAAM,OAAO,GAAG,YAAY,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC;AAC1D,IAAI;AACJ;AACA,IAAI,EAAE,cAAc,IAAI,CAAC,QAAQ,GAAG,QAAQ,GAAG,cAAc,EAAE,SAAS,CAAC;AACzE,QAAQ,EAAE,OAAO,IAAI,WAAW,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,EAAE;AAC5D,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,gBAAgB,SAAS,EAAE,GAAG,IAAI,EAAE;AACvD;AACA,QAAQ,MAAM,EAAE,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,OAAO,GAAG,WAAW,GAAG,UAAU,CAAC,CAAC;AACnF,QAAQ,IAAI,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC;AAC9B,QAAQ,IAAI,QAAQ;AACpB,YAAY,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;AAChD,QAAQ,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,cAAc,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC;AAChE,QAAQ,IAAI,OAAO;AACnB,YAAY,MAAM,EAAE,CAAC,IAAI,CAAC;AAC1B,QAAQ,OAAO,SAAS,CAAC;AACzB,KAAK,CAAC;AACN,IAAI,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AACpC,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,YAAY,CAAC,CAAC,QAAQ,MAAM;AAC5B,IAAI,GAAG,QAAQ;AACf,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,KAAK,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC;AACpG,IAAI,GAAG,EAAE,CAAC,MAAM,EAAE,IAAI,KAAK,CAAC,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC;AAClF,CAAC,CAAC,CAAC;;AChCH;;;MAGa,aAAa;IAmCxB,YACE,eAA4D,EAC5D,MAAe,EACf,SAAkB,EAClB,IAAiB,EACjB,iBAA0B;QAE1B,IAAI,CAAC,cAAc,GAAG,IAAI,CACxB,CAAA,eAAe,aAAf,eAAe,uBAAf,eAAe,CAAE,cAAc,CAAC,SAAS,KACpC,eAAuC;cACvC;gBACC,OAAO,EAAE,eAAe;gBACxB,MAAM;gBACN,SAAS;gBACT,IAAI;gBACJ,iBAAiB;aACM,CAC9B,CAAC;KACH;;;;;;;IAQK,GAAG,CAAC,GAAc;;YACtB,MAAM,CAAC,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,CAAC,EAAE,OAAO,EAAE,SAAS,CAAC,GAAG,MAAM,GAAG,CAAC;gBAC3F,IAAI,CAAC,cAAc;gBACnB,YAAY,CAAC,GAAG,CAAC;gBACjB,YAAY,CAAC,GAAG,GAAG,QAAQ,CAAC;aAC7B,CAAC,CAAC;YAEH,MAAM,WAAW,GAAG,MAAM,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;YACxD,IAAI,CAAC,WAAW;gBAAE,OAAO;YAEzB,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,GAAG,MAAM,GAAG,CAAC;gBACnC,cAAc,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,CAAC;gBAChD,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC;aAChC,CAAC,CAAC;YAEH,IAAI;gBACF,MAAM,KAAK,GAAG,MAAM,YAAY,CAAC,WAAW,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;gBAChE,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;aACtB;YAAC,OAAO,KAAK,EAAE;gBACd,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;aAClD;SACF;KAAA;;;;;;;;IASK,GAAG,CAAC,GAAc,EAAE,KAAgB;;YACxC,MAAM,CAAC,CAAC,KAAK,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,CAAC,EAAE,OAAO,EAAE,SAAS,CAAC,GAAG,MAAM,GAAG,CAAC;gBAC3F,IAAI,CAAC,cAAc;gBACnB,YAAY,CAAC,GAAG,CAAC;gBACjB,YAAY,CAAC,GAAG,GAAG,QAAQ,CAAC;aAC7B,CAAC,CAAC;YAEH,MAAM,SAAS,GAAG,MAAM,cAAc,CAAC,OAAO,EAAE,IAAI,EAAE,iBAAiB,CAAC,CAAC;YACzE,MAAM,CAAC,WAAW,EAAE,KAAK,CAAC,GAAG,MAAM,YAAY,CAAC,KAAK,EAAE,SAAS,CAAC,CAAC;YAClE,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,WAAW,EAAE,OAAO,CAAC,EAAE,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;SACjG;KAAA;;;;;;IAOK,KAAK;;YACT,MAAM,CAAC,KAAK,EAAE,SAAS,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC;YAC9D,MAAM,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAC7B,MAAM,UAAU,CAAC,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;SAC1C;KAAA;;;;;;IAOK,KAAK;;YACT,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC;YAC1C,KAAK,CAAC,KAAK,EAAE,CAAC;SACf;KAAA;;;;;;;IAQK,MAAM,CAAC,GAAc;;YACzB,MAAM,CAAC,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE,OAAO,EAAE,SAAS,CAAC,GAAG,MAAM,GAAG,CAAC;gBACzD,IAAI,CAAC,cAAc;gBACnB,YAAY,CAAC,GAAG,CAAC;gBACjB,YAAY,CAAC,GAAG,GAAG,QAAQ,CAAC;aAC7B,CAAC,CAAC;YACH,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;SACnF;KAAA;;;;;;;IAQK,QAAQ;;YACZ,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC;YAC1C,KAAK,CAAC,KAAK,EAAE,CAAC;YACd,MAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC5B;KAAA;;AApJD;;;AAGO,+BAAiB,GAAG,sCAAsC,CAAC;AAElE;;;AAGO,4BAAc,GAAG,iDAAiD,CAAC;AA+I5E;;;AAGA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAEtC;;;AAGA,MAAM,IAAI,GAAG,CAAO,EAClB,OAAO,EACP,MAAM,GAAG,sBAAsB,EAC/B,SAAS,GAAG,2BAA2B,EACvC,IAAI,EACJ,iBAAiB,GACG;IACpB,IAAI,CAAC,OAAO;QAAE,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;IAC5D,MAAM,CAAC,UAAU,EAAE,aAAa,EAAE,aAAa,CAAC,GAAG,MAAM,GAAG,CAAC;QAC3D,YAAY,CAAC,MAAM,CAAC;QACpB,YAAY,CAAC,SAAS,CAAC;QACvB,OAAO,YAAY,SAAS,GAAG,OAAO,GAAG,qBAAqB,CAAC,OAAO,CAAC;KACxE,CAAC,CAAC;IACH,MAAM,kBAAkB,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;IACjD,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;QAC1C,OAAO,CAAC,EAAE;YACR,EAAE,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,CAAC;SAC1C;KACF,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;QACT,KAAK;QACL,kBAAkB;QAClB,aAAa;QACb,UAAU,CAAC,KAAK,EAAE,kBAAkB,EAAE,IAAI,CAAC;QAC3C,iBAAiB;KAClB,CAAC,CAAC;AACL,CAAC,CAAA,CAAC;AAEF;;;AAGA,MAAM,UAAU,GAAG,CACjB,YAAkD,EAClD,SAAiB,EACjB,IAAiB;IAEjB,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC;IACtE,MAAM,YAAY,GAAG,MAAM,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACtD,IAAI,YAAY,KAAK,CAAC,IAAI,IAAI,YAAY,KAAK,IAAI,CAAC,EAAE;QACpD,OAAO,YAAY,CAAC;KACrB;IACD,OAAO,WAAW,CAAC,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;AACnD,CAAC,CAAA,CAAC;AAEF;;;AAGA,MAAM,WAAW,GAAG,CAClB,QAAoB,EACpB,KAAmB,EACnB,SAAiB,EACjB,WAAwB;IAExB,MAAM,IAAI,GAAG,WAAW,aAAX,WAAW,cAAX,WAAW,GAAI,YAAY,EAAE,CAAC;IAC3C,MAAM,KAAK,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC3C,OAAO,IAAI,CAAC;AACd,CAAC,CAAA;;;;"}