/**
 * Import Key Algorithms at Web Crypto API
 */
export declare type ImportAlgorithm = string | RsaHashedImportParams | EcKeyImportParams | HmacImportParams | DhImportKeyParams | AesKeyAlgorithm;
/**
 * Import Key Web Crypto Algorithms
 */
export declare type OriginalKeyFormat = 'raw' | 'pkcs8' | 'spki' | 'jwk';
/**
 * Derive Key Algorithms at at Web Crypto API
 */
export declare type DeriveAlgorithm = string | EcdhKeyDeriveParams | DhKeyDeriveParams | ConcatParams | HkdfCtrParams | Pbkdf2Params;
/**
 * Derive Algorithms Params for Web Crypto API
 */
export declare type DerivedAlgorithmFor = string | AesDerivedKeyParams | HmacImportParams | ConcatParams | HkdfCtrParams | Pbkdf2Params;
/**
 * Params for Encrypt / Decrypt Algorithms at Web Crypto API
 */
export declare type CryptoAlgorithm = string | RsaOaepParams | AesCtrParams | AesCbcParams | AesCmacParams | AesGcmParams | AesCfbParams;
/**
 * TypedArray used in Web Crypto API Algorithms
 */
export declare type TypedArray = Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;
/**
 * Possible uses of Crypto Keys
 */
export declare type CryptoKeyUsage = 'encrypt' | 'decrypt' | 'deriveKey' | 'deriveBits' | 'wrapKey' | 'sign' | 'verify' | 'unwrapKey';
/**
 * Default number of iterations used with PBKDF2 algorithm
 */
export declare const PBKDF2_ITERATIONS_DEFAULT: number;
/**
 * @internal
 */
declare global {
    /**
     * IE11 use a different global property.
     * @internal
     */
    var msCrypto: Crypto;
}
/**
 * Returns the crypto object depending on browser support.
 * IE11 has support for the Crypto API, but it is in a different global scope.
 *
 * @returns The Crypto object.
 */
export declare function getCryptoObject(): Crypto;
/**
 * Creates a base Crypto Key from the original raw key, by default this base key
 * should just be used to protect the original key to be discovery,
 * and should not be used directly to any encrypt / decrypt algorithm.
 * The generated base crypto key should be used just to derive new ones,
 * that then will be used to encrypt / decrypt algorithms.
 *
 * @param rawKey The original key to start the encrypt process.
 * @param algorithm The algorithm used to import the key.
 * @param keyUsages The uses for the generated Crypto Key.
 * @param format Input format for the raw key.
 * @returns A promise with the base Crypto Key.
 */
export declare function generateBaseCryptoKey(rawKey: string | TypedArray | JsonWebKey, algorithm?: ImportAlgorithm, keyUsages?: KeyUsage[], format?: OriginalKeyFormat): Promise<CryptoKey>;
/**
 * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms
 * or any other possible uses in `CryptoKeyUsage`.
 *
 * @param cryptoBaseKey The base Crypto Key to be derive.
 * @param salt The salt value to be used with the default `PBKDF2` derive algorithm.
 * @param iterations The number of iterations to be used with the default `PBKDF2` derive algorithm. Default value: `PBKDF2_ITERATIONS_DEFAULT`.
 * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.
 * @returns A promise with the derived Crypto Key for other uses.
 */
export declare function deriveCryptKey(cryptoBaseKey: CryptoKey, salt: TypedArray, iterations?: number, keyUsages?: CryptoKeyUsage[]): Promise<CryptoKey>;
/**
 * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms
 * or any other possible uses in `CryptoKeyUsage`.
 *
 * @param cryptoBaseKey The base Crypto Key to be derive.
 * @param salt The salt value to be used with the default `PBKDF2` derive algorithm.
 * @param algorithmFor The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`.
 * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.
 * @returns A promise with the derived Crypto Key for other uses.
 */
export declare function deriveCryptKey(cryptoBaseKey: CryptoKey, salt: TypedArray, algorithmFor?: DerivedAlgorithmFor, keyUsages?: CryptoKeyUsage[]): Promise<CryptoKey>;
/**
 * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms
 * or any other possible uses in `CryptoKeyUsage`.
 *
 * @param cryptoBaseKey The base Crypto Key to be derive.
 * @param deriveAlgorithm The algorithm to be used when deriving the Crypto Key.
 * @param algorithmFor The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`.
 * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.
 * @returns A promise with the derived Crypto Key for other uses.
 */
export declare function deriveCryptKey(cryptoBaseKey: CryptoKey, deriveAlgorithm: DeriveAlgorithm, algorithmFor?: DerivedAlgorithmFor, keyUsages?: CryptoKeyUsage[]): Promise<CryptoKey>;
/**
 * Type Guard to Typed Array.
 *
 * @param data Any data to be checked.
 * @returns Verify if the given data is a Typed Array.
 */
export declare function isTypedArray(data: unknown): data is TypedArray;
/**
 * Encrypt a value with the given Crypto Key and Algorithm
 *
 * @param data Value to be encrypted.
 * @param cryptoKey The Crypto Key to be used in encryption.
 * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.
 * @returns A promise with the encrypted value and the used nonce, if used with the encryption algorithm.
 */
export declare function encryptValue(data: string | TypedArray, cryptoKey: CryptoKey, algorithm?: CryptoAlgorithm): Promise<[ArrayBuffer, TypedArray | null]>;
/**
 * Decrypt a value with the given Crypto Key and Algorithm
 *
 * @param data Value to be encrypted.
 * @param cryptoKey The Crypto Key used in encryption.
 * @param nonceOrAlgorithm The nonce used for AES encryption or the custom algorithm.
 * @returns A promise with the decrypt value
 */
export declare function decryptValue(data: TypedArray, cryptoKey: CryptoKey, nonceOrAlgorithm: TypedArray | CryptoAlgorithm): Promise<ArrayBuffer>;
/**
 * Generates random value to be used as nonce with encryption algorithms.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
export declare function generateNonce(byteSize?: number): Uint8Array;
/**
 * Generates random value to be used as salt with encryption algorithms.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
export declare function generateSalt(byteSize?: number): Uint8Array;
/**
 * Generates random value as a typed array of `Uint8Array`.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
export declare function generateRandomValues(byteSize?: number): Uint8Array;
/**
 * Encode a string value to a Typed Array as `Uint8Array`.
 * If the given value is already a Typed Array, then the value will be returned without any transformation.
 *
 * @param data Value to be encoded.
 * @returns The transformed given value as a Typed Array.
 */
export declare function encode(data: string | TypedArray): TypedArray;
/**
 * Decode a ArrayBuffer value to a string.
 * If the given value is already a string, then the value will be returned without any transformation.
 *
 * @param data Value to be decoded.
 * @returns The transformed given value as a string.
 */
export declare function decode(data: string | TypedArray): string;
/**
 * Generates a hash value for the given value.
 *
 * @param data Seed value to generate a hash.
 * @param algorithm The algorithm to be used when generating the hash.
 * @returns A promise containing the hash value.
 */
export declare function generateHash(data: string | TypedArray, algorithm?: string | Algorithm): Promise<ArrayBuffer>;
