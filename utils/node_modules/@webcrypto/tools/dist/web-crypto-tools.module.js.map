{"version":3,"file":"web-crypto-tools.module.js","sources":["../src/web-crypto-tools.ts"],"sourcesContent":["/**\n * Import Key Algorithms at Web Crypto API\n */\nexport type ImportAlgorithm =\n  | string\n  | RsaHashedImportParams\n  | EcKeyImportParams\n  | HmacImportParams\n  | DhImportKeyParams\n  | AesKeyAlgorithm;\n\n/**\n * Import Key Web Crypto Algorithms\n */\nexport type OriginalKeyFormat = 'raw' | 'pkcs8' | 'spki' | 'jwk';\n\n/**\n * Derive Key Algorithms at at Web Crypto API\n */\nexport type DeriveAlgorithm =\n  | string\n  | EcdhKeyDeriveParams\n  | DhKeyDeriveParams\n  | ConcatParams\n  | HkdfCtrParams\n  | Pbkdf2Params;\n\n/**\n * Derive Algorithms Params for Web Crypto API\n */\nexport type DerivedAlgorithmFor =\n  | string\n  | AesDerivedKeyParams\n  | HmacImportParams\n  | ConcatParams\n  | HkdfCtrParams\n  | Pbkdf2Params;\n\n/**\n * Params for Encrypt / Decrypt Algorithms at Web Crypto API\n */\nexport type CryptoAlgorithm =\n  | string\n  | RsaOaepParams\n  | AesCtrParams\n  | AesCbcParams\n  | AesCmacParams\n  | AesGcmParams\n  | AesCfbParams;\n\n/**\n * TypedArray used in Web Crypto API Algorithms\n */\nexport type TypedArray =\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array\n  | DataView\n  | ArrayBuffer;\n\n/**\n * Possible uses of Crypto Keys\n */\nexport type CryptoKeyUsage =\n  | 'encrypt'\n  | 'decrypt'\n  | 'deriveKey'\n  | 'deriveBits'\n  | 'wrapKey'\n  | 'sign'\n  | 'verify'\n  | 'unwrapKey';\n\n/**\n * Default number of iterations used with PBKDF2 algorithm\n */\nexport const PBKDF2_ITERATIONS_DEFAULT: number = 50000;\n\n/**\n * @internal\n */\ndeclare global {\n  /**\n   * IE11 use a different global property.\n   * @internal\n   */\n  var msCrypto: Crypto;\n}\n\n/**\n * Returns the crypto object depending on browser support.\n * IE11 has support for the Crypto API, but it is in a different global scope.\n *\n * @returns The Crypto object.\n */\nexport function getCryptoObject(): Crypto {\n  return window.crypto || window.msCrypto; // for IE 11\n}\n\n/**\n * Creates a base Crypto Key from the original raw key, by default this base key\n * should just be used to protect the original key to be discovery,\n * and should not be used directly to any encrypt / decrypt algorithm.\n * The generated base crypto key should be used just to derive new ones,\n * that then will be used to encrypt / decrypt algorithms.\n *\n * @param rawKey The original key to start the encrypt process.\n * @param algorithm The algorithm used to import the key.\n * @param keyUsages The uses for the generated Crypto Key.\n * @param format Input format for the raw key.\n * @returns A promise with the base Crypto Key.\n */\nexport function generateBaseCryptoKey(\n  rawKey: string | TypedArray | JsonWebKey,\n  algorithm: ImportAlgorithm = 'PBKDF2',\n  keyUsages: KeyUsage[] = ['deriveKey'],\n  format: OriginalKeyFormat = 'raw',\n): Promise<CryptoKey> {\n  const isJwkKey = !isTypedArray(rawKey) && typeof rawKey === 'object';\n  return Promise.resolve(\n    getCryptoObject().subtle.importKey(\n      isJwkKey ? 'jwk' : format,\n      typeof rawKey === 'string' ? encode(rawKey) : rawKey,\n      algorithm,\n      false, // the original value will not be extractable\n      keyUsages,\n    ),\n  );\n}\n\n/**\n * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms\n * or any other possible uses in `CryptoKeyUsage`.\n *\n * @param cryptoBaseKey The base Crypto Key to be derive.\n * @param salt The salt value to be used with the default `PBKDF2` derive algorithm.\n * @param iterations The number of iterations to be used with the default `PBKDF2` derive algorithm. Default value: `PBKDF2_ITERATIONS_DEFAULT`.\n * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.\n * @returns A promise with the derived Crypto Key for other uses.\n */\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  salt: TypedArray,\n  iterations?: number,\n  keyUsages?: CryptoKeyUsage[],\n): Promise<CryptoKey>;\n\n/**\n * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms\n * or any other possible uses in `CryptoKeyUsage`.\n *\n * @param cryptoBaseKey The base Crypto Key to be derive.\n * @param salt The salt value to be used with the default `PBKDF2` derive algorithm.\n * @param algorithmFor The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`.\n * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.\n * @returns A promise with the derived Crypto Key for other uses.\n */\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  salt: TypedArray,\n  algorithmFor?: DerivedAlgorithmFor,\n  keyUsages?: CryptoKeyUsage[],\n): Promise<CryptoKey>;\n\n/**\n * Derives a base Crypto Key to new one that can be used in encrypt / decrypt algorithms\n * or any other possible uses in `CryptoKeyUsage`.\n *\n * @param cryptoBaseKey The base Crypto Key to be derive.\n * @param deriveAlgorithm The algorithm to be used when deriving the Crypto Key.\n * @param algorithmFor The algorithm where the derived Crypto Key will be used. Default value: `{ name: 'AES-GCM', length: 256 }`.\n * @param keyUsages The new uses of the new derive Crypto Key. Default value: `['encrypt', 'decrypt']`.\n * @returns A promise with the derived Crypto Key for other uses.\n */\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  deriveAlgorithm: DeriveAlgorithm,\n  algorithmFor?: DerivedAlgorithmFor,\n  keyUsages?: CryptoKeyUsage[],\n): Promise<CryptoKey>;\n\nexport function deriveCryptKey(\n  cryptoBaseKey: CryptoKey,\n  deriveAlgorithmOrSalt: DeriveAlgorithm | TypedArray,\n  algorithmForOrIterations: DerivedAlgorithmFor | number = PBKDF2_ITERATIONS_DEFAULT,\n  keyUsages: CryptoKeyUsage[] = ['encrypt', 'decrypt'],\n): Promise<CryptoKey> {\n  const deriveAlgorithm = isTypedArray(deriveAlgorithmOrSalt)\n    ? ({\n        name: 'PBKDF2',\n        hash: 'SHA-256',\n        salt: deriveAlgorithmOrSalt,\n        iterations:\n          typeof algorithmForOrIterations === 'number'\n            ? algorithmForOrIterations\n            : PBKDF2_ITERATIONS_DEFAULT,\n      } as Pbkdf2Params)\n    : deriveAlgorithmOrSalt;\n\n  // The derived key will be used to encrypt with AES by default.\n  const algorithmFor =\n    typeof algorithmForOrIterations === 'number'\n      ? ({ name: 'AES-GCM', length: 256 } as AesDerivedKeyParams)\n      : algorithmForOrIterations;\n\n  return Promise.resolve(\n    getCryptoObject().subtle.deriveKey(\n      deriveAlgorithm,\n      cryptoBaseKey,\n      algorithmFor,\n      false, // the original key will not be extractable\n      keyUsages,\n    ),\n  );\n}\n\n/**\n * Type Guard to Typed Array.\n *\n * @param data Any data to be checked.\n * @returns Verify if the given data is a Typed Array.\n */\nexport function isTypedArray(data: unknown): data is TypedArray {\n  return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;\n}\n\n/**\n * Encrypt a value with the given Crypto Key and Algorithm\n *\n * @param data Value to be encrypted.\n * @param cryptoKey The Crypto Key to be used in encryption.\n * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.\n * @returns A promise with the encrypted value and the used nonce, if used with the encryption algorithm.\n */\nexport function encryptValue(\n  data: string | TypedArray,\n  cryptoKey: CryptoKey,\n  algorithm: CryptoAlgorithm = { name: 'AES-GCM', iv: generateNonce() } as AesGcmParams,\n): Promise<[ArrayBuffer, TypedArray | null]> {\n  return Promise.resolve(\n    getCryptoObject().subtle.encrypt(algorithm, cryptoKey, encode(data)),\n  ).then(cryptoValue => [cryptoValue, (algorithm as AesGcmParams).iv || null]);\n}\n\n/**\n * Decrypt a value with the given Crypto Key and Algorithm\n *\n * @param data Value to be encrypted.\n * @param cryptoKey The Crypto Key used in encryption.\n * @param nonceOrAlgorithm The nonce used for AES encryption or the custom algorithm.\n * @returns A promise with the decrypt value\n */\nexport function decryptValue(\n  data: TypedArray,\n  cryptoKey: CryptoKey,\n  nonceOrAlgorithm: TypedArray | CryptoAlgorithm,\n): Promise<ArrayBuffer> {\n  const algorithm = isTypedArray(nonceOrAlgorithm)\n    ? ({ name: 'AES-GCM', iv: nonceOrAlgorithm } as AesGcmParams)\n    : nonceOrAlgorithm;\n  return Promise.resolve(getCryptoObject().subtle.decrypt(algorithm, cryptoKey, data));\n}\n\n/**\n * Generates random value to be used as nonce with encryption algorithms.\n *\n * @param byteSize The byte size of the generated random value.\n * @returns The random value.\n */\nexport function generateNonce(byteSize = 16): Uint8Array {\n  // We should generate at least 16 bytes\n  // to allow for 2^128 possible variations.\n  return generateRandomValues(byteSize);\n}\n\n/**\n * Generates random value to be used as salt with encryption algorithms.\n *\n * @param byteSize The byte size of the generated random value.\n * @returns The random value.\n */\nexport function generateSalt(byteSize = 8): Uint8Array {\n  // We should generate at least 8 bytes\n  // to allow for 2^64 possible variations.\n  return generateRandomValues(byteSize);\n}\n\n/**\n * Generates random value as a typed array of `Uint8Array`.\n *\n * @param byteSize The byte size of the generated random value.\n * @returns The random value.\n */\nexport function generateRandomValues(byteSize = 8): Uint8Array {\n  return getCryptoObject().getRandomValues(new Uint8Array(byteSize));\n}\n\n/**\n * Encode a string value to a Typed Array as `Uint8Array`.\n * If the given value is already a Typed Array, then the value will be returned without any transformation.\n *\n * @param data Value to be encoded.\n * @returns The transformed given value as a Typed Array.\n */\nexport function encode(data: string | TypedArray): TypedArray {\n  return isTypedArray(data) ? data : new TextEncoder().encode(data);\n}\n\n/**\n * Decode a ArrayBuffer value to a string.\n * If the given value is already a string, then the value will be returned without any transformation.\n *\n * @param data Value to be decoded.\n * @returns The transformed given value as a string.\n */\nexport function decode(data: string | TypedArray): string {\n  return typeof data === 'string' ? data : new TextDecoder('utf-8').decode(data);\n}\n\n/**\n * Generates a hash value for the given value.\n *\n * @param data Seed value to generate a hash.\n * @param algorithm The algorithm to be used when generating the hash.\n * @returns A promise containing the hash value.\n */\nexport function generateHash(\n  data: string | TypedArray,\n  algorithm: string | Algorithm = 'SHA-256',\n): Promise<ArrayBuffer> {\n  return Promise.resolve(getCryptoObject().subtle.digest(algorithm, encode(data)));\n}\n"],"names":[],"mappings":"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"}