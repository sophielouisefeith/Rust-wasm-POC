(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.webCryptoTools = {})));
}(this, (function (exports) { 'use strict';

  /**
   * Default number of iterations used with PBKDF2 algorithm
   */
  var PBKDF2_ITERATIONS_DEFAULT = 50000;
  /**
   * Returns the crypto object depending on browser support.
   * IE11 has support for the Crypto API, but it is in a different global scope.
   *
   * @returns The Crypto object.
   */
  function getCryptoObject() {
      return window.crypto || window.msCrypto; // for IE 11
  }
  /**
   * Creates a base Crypto Key from the original raw key, by default this base key
   * should just be used to protect the original key to be discovery,
   * and should not be used directly to any encrypt / decrypt algorithm.
   * The generated base crypto key should be used just to derive new ones,
   * that then will be used to encrypt / decrypt algorithms.
   *
   * @param rawKey The original key to start the encrypt process.
   * @param algorithm The algorithm used to import the key.
   * @param keyUsages The uses for the generated Crypto Key.
   * @param format Input format for the raw key.
   * @returns A promise with the base Crypto Key.
   */
  function generateBaseCryptoKey(rawKey, algorithm, keyUsages, format) {
      if (algorithm === void 0) { algorithm = 'PBKDF2'; }
      if (keyUsages === void 0) { keyUsages = ['deriveKey']; }
      if (format === void 0) { format = 'raw'; }
      var isJwkKey = !isTypedArray(rawKey) && typeof rawKey === 'object';
      return Promise.resolve(getCryptoObject().subtle.importKey(isJwkKey ? 'jwk' : format, typeof rawKey === 'string' ? encode(rawKey) : rawKey, algorithm, false, // the original value will not be extractable
      keyUsages));
  }
  function deriveCryptKey(cryptoBaseKey, deriveAlgorithmOrSalt, algorithmForOrIterations, keyUsages) {
      if (algorithmForOrIterations === void 0) { algorithmForOrIterations = PBKDF2_ITERATIONS_DEFAULT; }
      if (keyUsages === void 0) { keyUsages = ['encrypt', 'decrypt']; }
      var deriveAlgorithm = isTypedArray(deriveAlgorithmOrSalt)
          ? {
              name: 'PBKDF2',
              hash: 'SHA-256',
              salt: deriveAlgorithmOrSalt,
              iterations: typeof algorithmForOrIterations === 'number'
                  ? algorithmForOrIterations
                  : PBKDF2_ITERATIONS_DEFAULT,
          }
          : deriveAlgorithmOrSalt;
      // The derived key will be used to encrypt with AES by default.
      var algorithmFor = typeof algorithmForOrIterations === 'number'
          ? { name: 'AES-GCM', length: 256 }
          : algorithmForOrIterations;
      return Promise.resolve(getCryptoObject().subtle.deriveKey(deriveAlgorithm, cryptoBaseKey, algorithmFor, false, // the original key will not be extractable
      keyUsages));
  }
  /**
   * Type Guard to Typed Array.
   *
   * @param data Any data to be checked.
   * @returns Verify if the given data is a Typed Array.
   */
  function isTypedArray(data) {
      return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;
  }
  /**
   * Encrypt a value with the given Crypto Key and Algorithm
   *
   * @param data Value to be encrypted.
   * @param cryptoKey The Crypto Key to be used in encryption.
   * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.
   * @returns A promise with the encrypted value and the used nonce, if used with the encryption algorithm.
   */
  function encryptValue(data, cryptoKey, algorithm) {
      if (algorithm === void 0) { algorithm = { name: 'AES-GCM', iv: generateNonce() }; }
      return Promise.resolve(getCryptoObject().subtle.encrypt(algorithm, cryptoKey, encode(data))).then(function (cryptoValue) { return [cryptoValue, algorithm.iv || null]; });
  }
  /**
   * Decrypt a value with the given Crypto Key and Algorithm
   *
   * @param data Value to be encrypted.
   * @param cryptoKey The Crypto Key used in encryption.
   * @param nonceOrAlgorithm The nonce used for AES encryption or the custom algorithm.
   * @returns A promise with the decrypt value
   */
  function decryptValue(data, cryptoKey, nonceOrAlgorithm) {
      var algorithm = isTypedArray(nonceOrAlgorithm)
          ? { name: 'AES-GCM', iv: nonceOrAlgorithm }
          : nonceOrAlgorithm;
      return Promise.resolve(getCryptoObject().subtle.decrypt(algorithm, cryptoKey, data));
  }
  /**
   * Generates random value to be used as nonce with encryption algorithms.
   *
   * @param byteSize The byte size of the generated random value.
   * @returns The random value.
   */
  function generateNonce(byteSize) {
      if (byteSize === void 0) { byteSize = 16; }
      // We should generate at least 16 bytes
      // to allow for 2^128 possible variations.
      return generateRandomValues(byteSize);
  }
  /**
   * Generates random value to be used as salt with encryption algorithms.
   *
   * @param byteSize The byte size of the generated random value.
   * @returns The random value.
   */
  function generateSalt(byteSize) {
      if (byteSize === void 0) { byteSize = 8; }
      // We should generate at least 8 bytes
      // to allow for 2^64 possible variations.
      return generateRandomValues(byteSize);
  }
  /**
   * Generates random value as a typed array of `Uint8Array`.
   *
   * @param byteSize The byte size of the generated random value.
   * @returns The random value.
   */
  function generateRandomValues(byteSize) {
      if (byteSize === void 0) { byteSize = 8; }
      return getCryptoObject().getRandomValues(new Uint8Array(byteSize));
  }
  /**
   * Encode a string value to a Typed Array as `Uint8Array`.
   * If the given value is already a Typed Array, then the value will be returned without any transformation.
   *
   * @param data Value to be encoded.
   * @returns The transformed given value as a Typed Array.
   */
  function encode(data) {
      return isTypedArray(data) ? data : new TextEncoder().encode(data);
  }
  /**
   * Decode a ArrayBuffer value to a string.
   * If the given value is already a string, then the value will be returned without any transformation.
   *
   * @param data Value to be decoded.
   * @returns The transformed given value as a string.
   */
  function decode(data) {
      return typeof data === 'string' ? data : new TextDecoder('utf-8').decode(data);
  }
  /**
   * Generates a hash value for the given value.
   *
   * @param data Seed value to generate a hash.
   * @param algorithm The algorithm to be used when generating the hash.
   * @returns A promise containing the hash value.
   */
  function generateHash(data, algorithm) {
      if (algorithm === void 0) { algorithm = 'SHA-256'; }
      return Promise.resolve(getCryptoObject().subtle.digest(algorithm, encode(data)));
  }

  exports.PBKDF2_ITERATIONS_DEFAULT = PBKDF2_ITERATIONS_DEFAULT;
  exports.getCryptoObject = getCryptoObject;
  exports.generateBaseCryptoKey = generateBaseCryptoKey;
  exports.deriveCryptKey = deriveCryptKey;
  exports.isTypedArray = isTypedArray;
  exports.encryptValue = encryptValue;
  exports.decryptValue = decryptValue;
  exports.generateNonce = generateNonce;
  exports.generateSalt = generateSalt;
  exports.generateRandomValues = generateRandomValues;
  exports.encode = encode;
  exports.decode = decode;
  exports.generateHash = generateHash;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=web-crypto-tools.umd.js.map
