"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateHash = exports.decode = exports.encode = exports.generateRandomValues = exports.generateSalt = exports.generateNonce = exports.decryptValue = exports.encryptValue = exports.isTypedArray = exports.deriveCryptKey = exports.generateBaseCryptoKey = exports.getCryptoObject = exports.PBKDF2_ITERATIONS_DEFAULT = void 0;
/**
 * Default number of iterations used with PBKDF2 algorithm
 */
exports.PBKDF2_ITERATIONS_DEFAULT = 50000;
/**
 * Returns the crypto object depending on browser support.
 * IE11 has support for the Crypto API, but it is in a different global scope.
 *
 * @returns The Crypto object.
 */
function getCryptoObject() {
    return window.crypto || window.msCrypto; // for IE 11
}
exports.getCryptoObject = getCryptoObject;
/**
 * Creates a base Crypto Key from the original raw key, by default this base key
 * should just be used to protect the original key to be discovery,
 * and should not be used directly to any encrypt / decrypt algorithm.
 * The generated base crypto key should be used just to derive new ones,
 * that then will be used to encrypt / decrypt algorithms.
 *
 * @param rawKey The original key to start the encrypt process.
 * @param algorithm The algorithm used to import the key.
 * @param keyUsages The uses for the generated Crypto Key.
 * @param format Input format for the raw key.
 * @returns A promise with the base Crypto Key.
 */
function generateBaseCryptoKey(rawKey, algorithm = 'PBKDF2', keyUsages = ['deriveKey'], format = 'raw') {
    const isJwkKey = !isTypedArray(rawKey) && typeof rawKey === 'object';
    return Promise.resolve(getCryptoObject().subtle.importKey(isJwkKey ? 'jwk' : format, typeof rawKey === 'string' ? encode(rawKey) : rawKey, algorithm, false, // the original value will not be extractable
    keyUsages));
}
exports.generateBaseCryptoKey = generateBaseCryptoKey;
function deriveCryptKey(cryptoBaseKey, deriveAlgorithmOrSalt, algorithmForOrIterations = exports.PBKDF2_ITERATIONS_DEFAULT, keyUsages = ['encrypt', 'decrypt']) {
    const deriveAlgorithm = isTypedArray(deriveAlgorithmOrSalt)
        ? {
            name: 'PBKDF2',
            hash: 'SHA-256',
            salt: deriveAlgorithmOrSalt,
            iterations: typeof algorithmForOrIterations === 'number'
                ? algorithmForOrIterations
                : exports.PBKDF2_ITERATIONS_DEFAULT,
        }
        : deriveAlgorithmOrSalt;
    // The derived key will be used to encrypt with AES by default.
    const algorithmFor = typeof algorithmForOrIterations === 'number'
        ? { name: 'AES-GCM', length: 256 }
        : algorithmForOrIterations;
    return Promise.resolve(getCryptoObject().subtle.deriveKey(deriveAlgorithm, cryptoBaseKey, algorithmFor, false, // the original key will not be extractable
    keyUsages));
}
exports.deriveCryptKey = deriveCryptKey;
/**
 * Type Guard to Typed Array.
 *
 * @param data Any data to be checked.
 * @returns Verify if the given data is a Typed Array.
 */
function isTypedArray(data) {
    return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;
}
exports.isTypedArray = isTypedArray;
/**
 * Encrypt a value with the given Crypto Key and Algorithm
 *
 * @param data Value to be encrypted.
 * @param cryptoKey The Crypto Key to be used in encryption.
 * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.
 * @returns A promise with the encrypted value and the used nonce, if used with the encryption algorithm.
 */
function encryptValue(data, cryptoKey, algorithm = { name: 'AES-GCM', iv: generateNonce() }) {
    return Promise.resolve(getCryptoObject().subtle.encrypt(algorithm, cryptoKey, encode(data))).then(cryptoValue => [cryptoValue, algorithm.iv || null]);
}
exports.encryptValue = encryptValue;
/**
 * Decrypt a value with the given Crypto Key and Algorithm
 *
 * @param data Value to be encrypted.
 * @param cryptoKey The Crypto Key used in encryption.
 * @param nonceOrAlgorithm The nonce used for AES encryption or the custom algorithm.
 * @returns A promise with the decrypt value
 */
function decryptValue(data, cryptoKey, nonceOrAlgorithm) {
    const algorithm = isTypedArray(nonceOrAlgorithm)
        ? { name: 'AES-GCM', iv: nonceOrAlgorithm }
        : nonceOrAlgorithm;
    return Promise.resolve(getCryptoObject().subtle.decrypt(algorithm, cryptoKey, data));
}
exports.decryptValue = decryptValue;
/**
 * Generates random value to be used as nonce with encryption algorithms.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
function generateNonce(byteSize = 16) {
    // We should generate at least 16 bytes
    // to allow for 2^128 possible variations.
    return generateRandomValues(byteSize);
}
exports.generateNonce = generateNonce;
/**
 * Generates random value to be used as salt with encryption algorithms.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
function generateSalt(byteSize = 8) {
    // We should generate at least 8 bytes
    // to allow for 2^64 possible variations.
    return generateRandomValues(byteSize);
}
exports.generateSalt = generateSalt;
/**
 * Generates random value as a typed array of `Uint8Array`.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
function generateRandomValues(byteSize = 8) {
    return getCryptoObject().getRandomValues(new Uint8Array(byteSize));
}
exports.generateRandomValues = generateRandomValues;
/**
 * Encode a string value to a Typed Array as `Uint8Array`.
 * If the given value is already a Typed Array, then the value will be returned without any transformation.
 *
 * @param data Value to be encoded.
 * @returns The transformed given value as a Typed Array.
 */
function encode(data) {
    return isTypedArray(data) ? data : new TextEncoder().encode(data);
}
exports.encode = encode;
/**
 * Decode a ArrayBuffer value to a string.
 * If the given value is already a string, then the value will be returned without any transformation.
 *
 * @param data Value to be decoded.
 * @returns The transformed given value as a string.
 */
function decode(data) {
    return typeof data === 'string' ? data : new TextDecoder('utf-8').decode(data);
}
exports.decode = decode;
/**
 * Generates a hash value for the given value.
 *
 * @param data Seed value to generate a hash.
 * @param algorithm The algorithm to be used when generating the hash.
 * @returns A promise containing the hash value.
 */
function generateHash(data, algorithm = 'SHA-256') {
    return Promise.resolve(getCryptoObject().subtle.digest(algorithm, encode(data)));
}
exports.generateHash = generateHash;
//# sourceMappingURL=web-crypto-tools.js.map