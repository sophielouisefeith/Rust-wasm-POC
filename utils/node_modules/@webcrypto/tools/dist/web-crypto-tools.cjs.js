'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Default number of iterations used with PBKDF2 algorithm
 */
var PBKDF2_ITERATIONS_DEFAULT = 50000;
/**
 * Returns the crypto object depending on browser support.
 * IE11 has support for the Crypto API, but it is in a different global scope.
 *
 * @returns The Crypto object.
 */
function getCryptoObject() {
    return window.crypto || window.msCrypto; // for IE 11
}
/**
 * Creates a base Crypto Key from the original raw key, by default this base key
 * should just be used to protect the original key to be discovery,
 * and should not be used directly to any encrypt / decrypt algorithm.
 * The generated base crypto key should be used just to derive new ones,
 * that then will be used to encrypt / decrypt algorithms.
 *
 * @param rawKey The original key to start the encrypt process.
 * @param algorithm The algorithm used to import the key.
 * @param keyUsages The uses for the generated Crypto Key.
 * @param format Input format for the raw key.
 * @returns A promise with the base Crypto Key.
 */
function generateBaseCryptoKey(rawKey, algorithm, keyUsages, format) {
    if (algorithm === void 0) { algorithm = 'PBKDF2'; }
    if (keyUsages === void 0) { keyUsages = ['deriveKey']; }
    if (format === void 0) { format = 'raw'; }
    var isJwkKey = !isTypedArray(rawKey) && typeof rawKey === 'object';
    return Promise.resolve(getCryptoObject().subtle.importKey(isJwkKey ? 'jwk' : format, typeof rawKey === 'string' ? encode(rawKey) : rawKey, algorithm, false, // the original value will not be extractable
    keyUsages));
}
function deriveCryptKey(cryptoBaseKey, deriveAlgorithmOrSalt, algorithmForOrIterations, keyUsages) {
    if (algorithmForOrIterations === void 0) { algorithmForOrIterations = PBKDF2_ITERATIONS_DEFAULT; }
    if (keyUsages === void 0) { keyUsages = ['encrypt', 'decrypt']; }
    var deriveAlgorithm = isTypedArray(deriveAlgorithmOrSalt)
        ? {
            name: 'PBKDF2',
            hash: 'SHA-256',
            salt: deriveAlgorithmOrSalt,
            iterations: typeof algorithmForOrIterations === 'number'
                ? algorithmForOrIterations
                : PBKDF2_ITERATIONS_DEFAULT,
        }
        : deriveAlgorithmOrSalt;
    // The derived key will be used to encrypt with AES by default.
    var algorithmFor = typeof algorithmForOrIterations === 'number'
        ? { name: 'AES-GCM', length: 256 }
        : algorithmForOrIterations;
    return Promise.resolve(getCryptoObject().subtle.deriveKey(deriveAlgorithm, cryptoBaseKey, algorithmFor, false, // the original key will not be extractable
    keyUsages));
}
/**
 * Type Guard to Typed Array.
 *
 * @param data Any data to be checked.
 * @returns Verify if the given data is a Typed Array.
 */
function isTypedArray(data) {
    return ArrayBuffer.isView(data) || data instanceof ArrayBuffer;
}
/**
 * Encrypt a value with the given Crypto Key and Algorithm
 *
 * @param data Value to be encrypted.
 * @param cryptoKey The Crypto Key to be used in encryption.
 * @param algorithm The algorithm to be used in encryption. Default to `AES-GCM`.
 * @returns A promise with the encrypted value and the used nonce, if used with the encryption algorithm.
 */
function encryptValue(data, cryptoKey, algorithm) {
    if (algorithm === void 0) { algorithm = { name: 'AES-GCM', iv: generateNonce() }; }
    return Promise.resolve(getCryptoObject().subtle.encrypt(algorithm, cryptoKey, encode(data))).then(function (cryptoValue) { return [cryptoValue, algorithm.iv || null]; });
}
/**
 * Decrypt a value with the given Crypto Key and Algorithm
 *
 * @param data Value to be encrypted.
 * @param cryptoKey The Crypto Key used in encryption.
 * @param nonceOrAlgorithm The nonce used for AES encryption or the custom algorithm.
 * @returns A promise with the decrypt value
 */
function decryptValue(data, cryptoKey, nonceOrAlgorithm) {
    var algorithm = isTypedArray(nonceOrAlgorithm)
        ? { name: 'AES-GCM', iv: nonceOrAlgorithm }
        : nonceOrAlgorithm;
    return Promise.resolve(getCryptoObject().subtle.decrypt(algorithm, cryptoKey, data));
}
/**
 * Generates random value to be used as nonce with encryption algorithms.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
function generateNonce(byteSize) {
    if (byteSize === void 0) { byteSize = 16; }
    // We should generate at least 16 bytes
    // to allow for 2^128 possible variations.
    return generateRandomValues(byteSize);
}
/**
 * Generates random value to be used as salt with encryption algorithms.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
function generateSalt(byteSize) {
    if (byteSize === void 0) { byteSize = 8; }
    // We should generate at least 8 bytes
    // to allow for 2^64 possible variations.
    return generateRandomValues(byteSize);
}
/**
 * Generates random value as a typed array of `Uint8Array`.
 *
 * @param byteSize The byte size of the generated random value.
 * @returns The random value.
 */
function generateRandomValues(byteSize) {
    if (byteSize === void 0) { byteSize = 8; }
    return getCryptoObject().getRandomValues(new Uint8Array(byteSize));
}
/**
 * Encode a string value to a Typed Array as `Uint8Array`.
 * If the given value is already a Typed Array, then the value will be returned without any transformation.
 *
 * @param data Value to be encoded.
 * @returns The transformed given value as a Typed Array.
 */
function encode(data) {
    return isTypedArray(data) ? data : new TextEncoder().encode(data);
}
/**
 * Decode a ArrayBuffer value to a string.
 * If the given value is already a string, then the value will be returned without any transformation.
 *
 * @param data Value to be decoded.
 * @returns The transformed given value as a string.
 */
function decode(data) {
    return typeof data === 'string' ? data : new TextDecoder('utf-8').decode(data);
}
/**
 * Generates a hash value for the given value.
 *
 * @param data Seed value to generate a hash.
 * @param algorithm The algorithm to be used when generating the hash.
 * @returns A promise containing the hash value.
 */
function generateHash(data, algorithm) {
    if (algorithm === void 0) { algorithm = 'SHA-256'; }
    return Promise.resolve(getCryptoObject().subtle.digest(algorithm, encode(data)));
}

exports.PBKDF2_ITERATIONS_DEFAULT = PBKDF2_ITERATIONS_DEFAULT;
exports.getCryptoObject = getCryptoObject;
exports.generateBaseCryptoKey = generateBaseCryptoKey;
exports.deriveCryptKey = deriveCryptKey;
exports.isTypedArray = isTypedArray;
exports.encryptValue = encryptValue;
exports.decryptValue = decryptValue;
exports.generateNonce = generateNonce;
exports.generateSalt = generateSalt;
exports.generateRandomValues = generateRandomValues;
exports.encode = encode;
exports.decode = decode;
exports.generateHash = generateHash;
//# sourceMappingURL=web-crypto-tools.cjs.js.map
